use crate::airy::Airy;
use crate::cheb::cheb_eval_e;
use crate::result::{SpecFunCode, SpecFunResult};
use lazy_static::lazy_static;

lazy_static! {
    // fit for f(x) = zofmzeta((x+1)/2), 0 <= mzeta <= 1
    static ref ZOFMZETA_A_DATA: [f64; 20] = [
        2.933_256_373_082_935,
        0.489_651_822_484_703_7,
        0.022_863_761_735_538_085,
        -0.000_171_573_137_728_469_3,
        -0.000_010_592_753_814_875_1,
        1.059_560_253_041_9e-6,
        -4.680_160_516_91e-8,
        5.831_002_0e-12,
        1.766_537_581e-10,
        -1.450_346_40e-11,
        4.357_772e-13,
        4.60971e-14,
        -2.57571e-14,
        2.26468e-14,
        -2.22053e-14,
        2.08593e-14,
        -1.84454e-14,
        1.50150e-14,
        -1.06506e-14,
        5.5375e-15,
    ];

    // fit for f(x) = zofmzeta((9x+11)/2), 1 <= mzeta <= 10
    static ref ZOFMZETA_B_DATA: [f64; 30] = [
        22.407_252_764_663_035,
        10.398_082_588_251_656,
        1.092_050_144_486_018_4,
        -0.071_111_274_777_921_6,
        0.008_990_125_336_059_704,
        -0.001_201_950_338_088_875,
        0.000_106_686_807_968_315,
        0.000_017_406_491_576_830,
        -0.000_014_946_669_657_805,
        6.189_984_487_752e-6,
        -2.049_466_715_178e-6,
        5.871_894_580_20e-7,
        -1.460_775_141_57e-7,
        2.980_393_613_2e-8,
        -3.817_692_108e-9,
        -4.669_804_16e-10,
        5.838_603_34e-10,
        -2.788_252_99e-10,
        1.016_826_88e-10,
        -3.120_992_8e-11,
        8.111_122e-12,
        -1.663_986e-12,
        1.81364e-13,
        5.3414e-14,
        -4.7234e-14,
        2.1689e-14,
        -7.815e-15,
        2.371e-15,
        -6.04e-16,
        1.20e-16,
    ];

    // fit for f(x) = zofmzeta(mz(x))/mz(x)^(3/2),
    // mz(x) = (2/(x+1))^(2/3) 10
    // 10 <= mzeta <= Inf
    static ref ZOFMZETA_C_DATA: [f64; 11] = [
        1.382_476_122_712_291_3,
        0.024_485_610_168_677_424,
        -0.000_084_286_649_628_254_0,
        1.465_607_656_977_1e-6,
        -3.148_740_994_76e-8,
        7.561_134_833e-10,
        -1.945_316_43e-11,
        5.245_878e-13,
        -1.46380e-14,
        4.192e-16,
        -1.23e-17,
    ];

    /* Chebyshev fit for f(x) = z(x)^6 A_3(z(x)),  z(x) = 22/(10(x+1)) */
    static ref A3_GT1_DATA: [f64; 31] = [
        -0.123_783_199_829_515_3,
        0.104_636_462_534_700_7,
        -0.067_500_816_575_851_83,
        0.035_563_362_418_888_48,
        -0.016_073_852_403_597_94,
        0.006_449_787_825_285_11,
        -0.002_354_082_611_334_496_4,
        0.000_795_457_028_513_021_5,
        -0.000_252_149_207_458_550_8,
        0.000_075_740_045_960_693_93,
        -0.000_021_729_179_663_396_236,
        5.991_481_072_786_891e-6,
        -1.595_878_157_180_899_2e-6,
        4.123_298_651_290_372e-7,
        -1.036_972_599_341_765_9e-7,
        2.545_798_230_426_654_3e-8,
        -6.116_171_505_379_175e-9,
        1.440_934_619_913_866e-9,
        -3.335_044_595_625_556e-10,
        7.595_068_657_291_9e-11,
        -1.704_229_633_440_943e-11,
        3.772_352_502_062_623e-12,
        -8.246_023_763_573_398e-13,
        1.781_696_152_799_779_8e-13,
        -3.808_410_150_654_179_3e-14,
        8.059_366_993_091_61e-15,
        -1.689_656_596_164_173_9e-15,
        3.511_565_180_588_844_4e-16,
        -7.238_477_193_856_926e-17,
        1.480_659_897_767_717_6e-17,
        -3.006_928_575_078_730_5e-18,
    ];

    // chebyshev expansion for f(x) = z(x)^8 A_4(z(x)), z(x) = 12/(5(x+1))
    static ref A4_GT1_DATA: [f64; 30] = [
        1.153_093_293_911_985,
        -1.018_127_017_286_693_4,
        0.719_640_222_705_556_8,
        -0.423_599_639_771_726_9,
        0.215_024_488_759_339_55,
        -0.096_751_915_348_145_95,
        0.039_413_982_058_824_31,
        -0.014_775_225_692_561_698,
        0.005_162_114_514_159_37,
        -0.001_697_834_464_455_243_2,
        0.000_529_956_678_730_068_5,
        -0.000_158_020_275_749_964_78,
        0.000_045_254_366_680_989_69,
        -0.000_012_503_722_965_474_639,
        3.345_765_699_811_915e-6,
        -8.698_157_524_115_075e-7,
        2.203_089_548_432_564_6e-7,
        -5.449_336_949_260_068e-8,
        1.319_045_728_172_482_9e-8,
        -3.130_156_018_337_738e-9,
        7.293_780_252_712_335e-10,
        -1.671_208_013_794_514e-10,
        3.770_005_324_821_36e-11,
        -8.382_453_884_881_722e-12,
        1.838_874_191_004_976_5e-12,
        -3.983_591_998_075_378e-13,
        8.528_882_713_654_662e-14,
        -1.806_022_786_911_441_8e-14,
        3.784_934_219_969_072_5e-15,
        -7.855_286_746_812_221e-16,
    ];

    // Chebyshev fit for f(x) = z(x)^3 B_2(z(x)), z(x) = 12/(5(x+1))
    static ref B2_GT1_DATA: [f64; 40] = [
        0.001_185_871_472_726_838_6,
        0.000_348_204_599_906_482_74,
        -0.000_304_113_044_256_397_7,
        0.000_028_120_662_840_123_435,
        0.000_044_935_252_959_016_13,
        -0.000_030_376_299_970_930_723,
        0.000_011_259_796_471_238_758,
        -2.483_253_396_951_777_4e-6,
        -9.900_381_364_053_78e-8,
        4.925_985_965_618_311e-7,
        -3.764_412_096_442_670_7e-7,
        2.288_782_852_133_462_6e-7,
        -1.320_268_737_082_220_5e-7,
        7.701_966_909_253_74e-8,
        -4.658_970_697_301_051e-8,
        2.939_647_623_301_392_3e-8,
        -1.929_323_061_198_828_2e-8,
        1.309_910_701_372_871_8e-8,
        -9.150_911_194_088_597e-9,
        6.548_347_297_192_561e-9,
        -4.783_125_358_213_997e-9,
        3.556_262_545_742_618e-9,
        -2.685_338_944_400_841_6e-9,
        2.055_473_866_713_42e-9,
        -1.592_317_201_951_742_7e-9,
        1.246_592_321_346_438_2e-9,
        -9.849_484_688_118_06e-10,
        7.843_867_449_937_213e-10,
        -6.287_756_791_834_295e-10,
        5.066_231_886_875_525e-10,
        -4.096_227_088_124_345_3e-10,
        3.316_868_467_737_491e-10,
        -2.682_940_661_984_745e-10,
        2.160_398_812_218_457e-10,
        -1.723_237_330_956_027_8e-10,
        1.351_270_908_961_147e-10,
        -1.028_535_473_253_866_3e-10,
        7.421_134_544_390_171e-11,
        -4.812_498_026_686_432e-11,
        2.366_653_469_447_630_5e-11,
    ];

    // Chebyshev fit for f(x) = z(x)^6 B_3(z(x)), z(x) = 12/(5(x+1))
    static ref B3_GT1_DATA: [f64; 30] = [
        -0.010_244_537_936_269_574,
        0.003_661_848_432_929_534_3,
        0.002_615_425_249_859_930_3,
        -0.003_618_738_941_035_315_5,
        0.002_187_856_415_769_227_4,
        -0.000_821_995_230_359_080_4,
        0.000_128_177_388_915_563_15,
        0.000_100_094_465_336_803_3,
        -0.000_128_829_334_466_377_43,
        0.000_101_362_642_026_965_14,
        -0.000_070_002_758_496_595_57,
        0.000_046_948_863_967_574_31,
        -0.000_031_900_038_697_178_38,
        0.000_022_314_536_684_477_753,
        -0.000_016_111_021_977_124_397,
        0.000_011_966_344_249_907_352,
        -9.098_692_039_893_122e-6,
        7.049_261_369_423_542e-6,
        -5.542_521_662_464_219e-6,
        4.407_188_471_423_029_6e-6,
        -3.532_859_550_679_166_4e-6,
        2.845_949_755_720_770_7e-6,
        -2.295_926_978_288_243_8e-6,
        1.847_147_403_752_899_6e-6,
        -1.473_833_312_481_164_6e-6,
        1.156_877_810_985_932_2e-6,
        -8.817_468_852_462_707e-7,
        6.370_585_696_442_684e-7,
        -4.135_879_149_996_193e-7,
        2.035_415_115_873_882e-7,
    ];

    // Chebyshev fit for f(x) = z(x) B_2(z(x)), z(x) = 2(x+1)/5
    static ref B2_LT1_DATA: [f64; 40] = [
        0.000_736_815_658_413_371_3,
        0.000_338_035_996_475_712_26,
        -0.000_082_517_232_192_397_53,
        -0.000_033_908_799_486_564_33,
        0.000_019_613_980_568_488_82,
        -2.355_937_459_041_514e-6,
        -1.790_550_170_804_060_8e-6,
        1.331_295_711_856_106_9e-6,
        -5.388_794_447_154_365e-7,
        1.496_030_560_413_814e-7,
        -1.833_772_282_672_743_3e-8,
        -1.331_914_307_629_443_4e-8,
        1.606_420_964_637_004_3e-8,
        -1.289_325_763_304_218e-8,
        9.616_927_508_617_916e-9,
        -7.181_850_228_070_353e-9,
        5.474_400_921_721_514e-9,
        -4.268_044_669_050_845e-9,
        3.394_166_500_926_617_4e-9,
        -2.744_071_407_222_167_3e-9,
        2.248_836_152_210_825_3e-9,
        -1.863_824_071_660_875e-9,
        1.559_235_094_080_537_3e-9,
        -1.314_574_393_773_233e-9,
        1.115_371_677_721_504_8e-9,
        -9.511_757_680_526_663e-10,
        8.142_879_955_323_488e-10,
        -6.989_377_081_354_878e-10,
        6.007_311_363_608_745e-10,
        -5.162_743_425_851_345e-10,
        4.429_099_319_507_490_6e-10,
        -3.785_297_859_996_686_7e-10,
        3.214_395_933_886_318e-10,
        -2.702_592_668_062_078e-10,
        2.238_485_777_245_791_8e-10,
        -1.812_507_166_427_668e-10,
        1.416_487_000_871_366_8e-10,
        -1.043_310_185_713_278_3e-10,
        6.866_391_016_839_249e-11,
        -3.406_831_317_795_224_4e-11,
    ];

    // Chebyshev fit for f(x) = B_3(2(x+1)/5)
    static ref B3_LT1_DATA: [f64; 40] = [
        -0.001_371_608_205_269_920_5,
        -0.000_254_749_379_511_010_5,
        0.000_247_629_755_478_958_8,
        0.000_052_296_572_814_801_97,
        -0.000_074_883_542_726_215_12,
        0.000_014_168_800_128_910_465,
        0.000_015_289_860_601_721_836,
        -0.000_016_686_722_970_785_905,
        0.000_010_617_651_895_364_59,
        -5.822_057_744_240_621e-6,
        3.332_242_374_385_59e-6,
        -2.232_924_058_030_038_4e-6,
        1.748_166_510_366_783e-6,
        -1.495_813_060_413_950_6e-6,
        1.327_591_461_078_931_2e-6,
        -1.193_760_773_925_644_6e-6,
        1.078_783_038_632_116_4e-6,
        -9.774_333_501_181_914e-7,
        8.872_931_890_369_332e-7,
        -8.067_114_629_212_567e-7,
        7.343_286_037_866_736e-7,
        -6.689_792_607_269_737e-7,
        6.096_661_970_373_561e-7,
        -5.555_409_528_450_796e-7,
        5.058_833_567_319_724e-7,
        -4.600_814_629_776_76e-7,
        4.176_134_851_568_814_4e-7,
        -3.780_323_000_698_945e-7,
        3.409_524_850_136_43e-7,
        -3.060_395_975_135_474_7e-7,
        2.730_013_417_936_569e-7,
        -2.415_802_825_076_231e-7,
        2.115_478_103_829_875_2e-7,
        -1.826_991_132_875_677e-7,
        1.548_489_508_580_851_3e-7,
        -1.278_280_685_155_581e-7,
        1.014_801_172_539_489_3e-7,
        -7.565_896_977_143_963e-8,
        5.022_634_228_649_128_4e-8,
        -2.504_964_566_025_988e-8,
    ];

    // Chebyshev fit for f(x) = A_3(9(x+1)/20)
    static ref A3_LT1_DATA: [f64; 40] = [
        -0.000_179_825_614_721_344_2,
        -0.000_365_586_038_375_252_8_f64,
        -0.000_028_193_980_559_296_29,
        0.000_167_045_398_638_757_36,
        -0.000_070_989_699_703_476_74,
        -8.447_084_394_234_423e-6,
        0.000_027_341_309_034_314_775,
        -0.000_019_907_383_848_982_17,
        0.000_010_000_417_627_823_509,
        -3.973_985_201_314_367e-6,
        1.226_535_776_644_957_4e-6,
        -1.887_555_843_064_240_4e-7,
        -1.374_822_060_601_612e-7,
        2.103_263_793_018_533_4e-7,
        -2.055_837_782_454_126_4e-7,
        1.823_773_848_126_548_5e-7,
        -1.581_302_478_463_810_5e-7,
        1.369_669_827_255_89e-7,
        -1.192_502_809_446_202_7e-7,
        1.044_771_690_293_502_5e-7,
        -9.206_483_248_943_754e-8,
        8.152_379_829_045_879e-8,
        -7.247_179_498_005_086e-8,
        6.461_443_295_597_113e-8,
        -5.772_409_512_556_095e-8,
        5.162_310_756_743_684e-8,
        -4.617_125_074_679_860_6e-8,
        4.125_662_199_865_016e-8,
        -3.678_892_554_315_981_7e-8,
        3.269_449_945_795_184e-8,
        -2.891_258_996_979_647e-8,
        2.539_252_887_253_740_3e-8,
        -2.209_157_079_337_264_8e-8,
        1.897_321_663_527_204_7e-8,
        -1.600_589_778_932_598_7e-8,
        1.316_192_945_422_058_7e-8,
        -1.041_666_517_719_380_4e-8,
        7.747_801_585_815_618e-9,
        -5.134_794_257_935_261e-9,
        2.558_354_159_458_672_2e-9,
    ];

    // chebyshev fit for f(x) = A_4(2(x+1)/5)
    static ref A4_LT1_DATA: [f64; 30] = [
        0.000_090_547_037_700_516_12,
        0.000_330_660_004_980_980_2,
        0.000_197_374_537_343_639_9,
        -0.000_154_908_097_259_320_38,
        -0.000_045_149_489_355_387_3,
        0.000_079_768_817_826_039_4,
        -0.000_033_145_661_545_447_41,
        -1.882_121_487_901_356_6e-6,
        0.000_011_478_875_650_552,
        -9.226_303_991_119_621e-6,
        5.140_112_825_037_778e-6,
        -2.384_182_189_517_22e-6,
        1.006_642_922_144_815_4e-6,
        -4.232_246_780_964_900_5e-7,
        2.001_320_315_357_934_8e-7,
        -1.186_895_011_788_867_4e-7,
        8.781_952_431_911_422e-8,
        -7.396_415_032_420_664e-8,
        6.578_043_150_763_717e-8,
        -5.965_105_319_302_265e-8,
        5.444_776_266_276_728e-8,
        -4.980_205_738_156_886e-8,
        4.557_136_819_469_434e-8,
        -4.168_211_717_354_764_4e-8,
        3.808_470_135_276_605e-8,
        -3.474_030_288_518_524e-8,
        3.161_655_706_470_151e-8,
        -2.868_573_948_768_955_5e-8,
        2.592_375_211_713_225_4e-8,
        -2.330_942_855_219_058_7e-8,
    ];
}

/// Invert [Abramowitz+Stegun, 9.3.39].
/// Assumes minus_zeta >= 0.
#[allow(dead_code)]
fn bessel_olver_zofmzeta(minus_zeta: f64) -> f64 {
    if minus_zeta < 1.0 {
        let x = 2.0 * minus_zeta - 1.0;
        let c = cheb_eval_e(x, &(*ZOFMZETA_A_DATA), -1.0, 1.0);
        c.val
    } else if minus_zeta < 10.0 {
        let x = (2.0 * minus_zeta - 11.0) / 9.0;
        let c = cheb_eval_e(x, &(*ZOFMZETA_B_DATA), -1.0, 1.0);
        c.val
    } else {
        let ten32 = 31.622_776_601_683_793_f64; // 10^(3/2)
        let p = (minus_zeta).powf(3.0 / 2.0);
        let x = 2.0 * ten32 / p - 1.0;
        let c = cheb_eval_e(x, &(*ZOFMZETA_C_DATA), -1.0, 1.0);
        c.val * p
    }
}

fn olver_b0(z: f64, abs_zeta: f64) -> f64 {
    if z < 0.98 {
        let t = 1.0 / (1.0 - z * z).sqrt();
        -5.0 / (48.0 * abs_zeta * abs_zeta) + t * (-3.0 + 5.0 * t * t) / (24.0 * (abs_zeta).sqrt())
    } else if z < 1.02 {
        let a: f64 = 1.0 - z;
        let c0: f64 = 0.017_998_872_141_355_33;
        let c1: f64 = 0.011_199_298_221_287_762;
        let c2: f64 = 0.005_940_406_978_601_43;
        let c3: f64 = 0.002_867_672_451_639_004;
        let c4: f64 = 0.001_233_918_905_256_727;
        let c5: f64 = 0.000_416_925_067_453_517_9;
        let c6: f64 = 0.000_033_017_338_508_594_98;
        let c7: f64 = -0.000_131_807_623_857_820_3;
        let c8: f64 = -0.000_190_687_037_005_084_72;

        c8.mul_add(a, c7)
            .mul_add(a, c6)
            .mul_add(a, c5)
            .mul_add(a, c4)
            .mul_add(a, c3)
            .mul_add(a, c2)
            .mul_add(a, c1)
            .mul_add(a, c0)
    } else {
        let t = 1.0 / (z * (1.0 - 1.0 / (z * z)).sqrt());
        -5.0 / (48.0 * abs_zeta * abs_zeta) + t * (3.0 + 5.0 * t * t) / (24.0 * (abs_zeta).sqrt())
    }
}

fn olver_b1(z: f64, abs_zeta: f64) -> f64 {
    if z < 0.88 {
        let t = 1.0 / (1.0 - z * z).sqrt();
        let t2 = t * t;
        let rz = (abs_zeta).sqrt();
        let z32 = rz * rz * rz;
        let z92 = z32 * z32 * z32;
        let term1 =
            t * t * t * (30375.0 - 369_603.0 * t2 + 765_765.0 * t2 * t2 - 425_425.0 * t2 * t2 * t2)
                / 414_720.0;
        let term2 = 85085.0 / (663_552.0 * z92);
        let term3 = 385.0 / 110_592. * t * (3.0 - 5.0 * t2) / (abs_zeta * abs_zeta * abs_zeta);
        let term4 = 5.0 / 55296.0 * t2 * (81.0 - 462.0 * t2 + 385.0 * t2 * t2) / z32;
        -(term1 + term2 + term3 + term4) / rz
    } else if z < 1.12 {
        let a: f64 = 1.0 - z;
        let c0: f64 = -0.001_492_829_532_134_291_7;
        let c1: f64 = -0.001_756_409_419_092_778_7;
        let c2: f64 = -0.001_133_461_488_741_749_2;
        let c3: f64 = -0.000_346_910_909_813_829_77;
        let c4: f64 = 0.000_227_525_161_048_392_44;
        let c5: f64 = 0.000_517_641_457_242_448_4;
        let c6: f64 = 0.000_589_061_748_581_942_3;
        let c7: f64 = 0.000_534_855_145_218_880_7;
        let c8: f64 = 0.000_428_917_929_862_201_5;
        let c9: f64 = 0.000_316_397_659_006_136_34;
        let c10: f64 = 0.000_219_081_476_786_995_94;

        c10.mul_add(a, c9)
            .mul_add(a, c8)
            .mul_add(a, c7)
            .mul_add(a, c6)
            .mul_add(a, c5)
            .mul_add(a, c4)
            .mul_add(a, c3)
            .mul_add(a, c2)
            .mul_add(a, c1)
            .mul_add(a, c0)
    } else {
        let t = 1.0 / (z * (1.0 - 1.0 / (z * z)).sqrt());
        let t2 = t * t;
        let rz = abs_zeta.sqrt();
        let z32 = rz * rz * rz;
        let z92 = z32 * z32 * z32;
        let term1 =
            -t2 * t * (30375.0 + 369_603.0 * t2 + 765_765.0 * t2 * t2 + 425_425.0 * t2 * t2 * t2)
                / 414_720.0;
        let term2 = 85085.0 / (663_552.0 * z92);
        let term3 = -385.0 / 110_592.0 * t * (3.0 + 5.0 * t2) / (abs_zeta * abs_zeta * abs_zeta);
        let term4 = 5.0 / 55296.0 * t2 * (81.0 + 462.0 * t2 + 385.0 * t2 * t2) / z32;
        (term1 + term2 + term3 + term4) / rz
    }
}

fn olver_b2(z: f64) -> f64 {
    if z < 0.8 {
        let x = 5.0 * z / 2.0 - 1.0;
        let c = cheb_eval_e(x, &(*B2_LT1_DATA), -1.0, 1.0);
        c.val / z
    } else if z <= 1.2 {
        let a: f64 = 1.0 - z;
        let c0: f64 = 0.000_552_213_076_721_292_8;
        let c1: f64 = 0.000_895_865_163_104_769_3;
        let c2: f64 = 0.000_670_150_034_415_697_7;
        let c3: f64 = 0.000_101_662_633_619_490_46;
        let c4: f64 = -0.000_440_863_451_338_068_86;
        let c5: f64 = -0.000_739_630_815_087_887_4;
        let c6: f64 = -0.000_767_454_943_778_395_6;
        let c7: f64 = -0.000_608_290_381_060_403_7;
        let c8: f64 = -0.000_371_287_075_288_934_96;
        let c9: f64 = -0.000_141_163_251_057_026_1;

        c9.mul_add(a, c8)
            .mul_add(a, c7)
            .mul_add(a, c6)
            .mul_add(a, c5)
            .mul_add(a, c4)
            .mul_add(a, c3)
            .mul_add(a, c2)
            .mul_add(a, c1)
            .mul_add(a, c0)
    } else {
        let zi = 1.0 / z;
        let x = 12.0 / 5.0 * zi - 1.0;
        let c = cheb_eval_e(x, &(*B2_GT1_DATA), -1.0, 1.0);
        c.val * zi * zi * zi
    }
}

fn olver_b3(z: f64) -> f64 {
    if z < 0.8 {
        let x = 5.0 * z / 2.0 - 1.0;
        let c = cheb_eval_e(x, &(*B3_LT1_DATA), -1.0, 1.0);
        c.val
    } else if z < 1.2 {
        let a: f64 = 1.0 - z;
        let c0: f64 = -0.000_474_617_796_559_959_8;
        let c1: f64 = -0.000_955_729_134_294_643;
        let c2: f64 = -0.000_803_696_345_120_829;
        let c3: f64 = -0.000_007_279_216_691_547_842;
        let c4: f64 = 0.000_931_625_003_315_813_5;
        let c5: f64 = 0.001_498_487_969_137_515;
        let c6: f64 = 0.001_484_060_396_759_497_4;

        c6.mul_add(a, c5)
            .mul_add(a, c4)
            .mul_add(a, c3)
            .mul_add(a, c2)
            .mul_add(a, c1)
            .mul_add(a, c0)
    } else {
        let x = 12.0 / (5.0 * z) - 1.0;
        let zi2 = 1.0 / (z * z);
        let c = cheb_eval_e(x, &(*B3_GT1_DATA), -1.0, 1.0);
        c.val * zi2 * zi2 * zi2
    }
}

fn olver_a1(z: f64, abs_zeta: f64) -> (f64, f64) {
    if z < 0.98 {
        let t = 1.0 / (1.0 - z * z).sqrt();
        let rz = abs_zeta.sqrt();
        let t2 = t * t;
        let term1 = t2 * (81.0 - 462.0 * t2 + 385.0 * t2 * t2) / 1152.0;
        let term2 = -455.0 / (4608.0 * abs_zeta * abs_zeta * abs_zeta);
        let term3 = 7.0 * t * (-3.0 + 5.0 * t2) / (1152.0 * rz * rz * rz);
        let err = 2.0 * f64::EPSILON * (term1.abs() + term2.abs() + term3.abs());
        (term1 + term2 + term3, err)
    } else if z < 1.02 {
        let a: f64 = 1.0 - z;
        let c0: f64 = -0.004_444_444_444_444_444_4;
        let c1: f64 = -0.001_844_155_844_155_844;
        let c2: f64 = 0.000_568_120_768_120_768_1;
        let c3: f64 = 0.001_681_378_656_616_752;
        let c4: f64 = 0.001_867_440_421_390_001_2;
        let c5: f64 = 0.001_613_301_058_337_478_2;
        let c6: f64 = 0.001_231_773_122_206_258_2;
        let c7: f64 = 0.000_873_347_110_073_775_7;
        let c8: f64 = 0.000_590_049_424_553_532_5;
        let sum = c8
            .mul_add(a, c7)
            .mul_add(a, c6)
            .mul_add(a, c5)
            .mul_add(a, c4)
            .mul_add(a, c3)
            .mul_add(a, c2)
            .mul_add(a, c1)
            .mul_add(a, c0);

        let err = 2.0 * f64::EPSILON * sum.abs();
        (sum, err)
    } else {
        let t = 1.0 / (z * (1.0 - 1.0 / (z * z)).sqrt());
        let rz = (abs_zeta).sqrt();
        let t2 = t * t;
        let term1 = -t2 * (81.0 + 462.0 * t2 + 385.0 * t2 * t2) / 1152.0;
        let term2 = 455.0 / (4608.0 * abs_zeta * abs_zeta * abs_zeta);
        let term3 = -7.0 * t * (3.0 + 5.0 * t2) / (1152.0 * rz * rz * rz);
        let err = 2.0 * f64::EPSILON * (term1.abs() + term2.abs() + term3.abs());
        (term1 + term2 + term3, err)
    }
}

fn olver_a2(z: f64, abs_zeta: f64) -> f64 {
    if z < 0.88 {
        let t = 1.0 / (1.0 - z * z).sqrt();
        let t2 = t * t;
        let t4 = t2 * t2;
        let t6 = t4 * t2;
        let t8 = t4 * t4;
        let rz = abs_zeta.sqrt();
        let z3 = abs_zeta * abs_zeta * abs_zeta;
        let z32 = rz * rz * rz;
        let z92 = z3 * z32;
        let term1 = t4
            * (4_465_125.0 - 94_121_676.0 * t2 + 349_922_430.0 * t4 - 446_185_740.0 * t6
            + 185_910_725.0 * t8)
            / 39_813_120.0;
        let term2 = -40_415_375.0 / (127_401_984.0 * z3 * z3);
        let term3 = -95095.0 / 15_925_248.0 * t * (3.0 - 5.0 * t2) / z92;
        let term4 = -455.0 / 5_308_416.0 * t2 * (81.0 - 462.0 * t2 + 385.0 * t4) / z3;
        let term5 =
            -7.0 / 19_906_560.0 * t * t2 * (30375.0 - 369_603.0 * t2 + 765_765.0 * t4 - 425_425.0 * t6)
                / z32;
        term1 + term2 + term3 + term4 + term5
    } else if z < 1.12 {
        let a: f64 = 1.0 - z;
        let c0: f64 = 0.000_693_735_541_354_589;
        let c1: f64 = 0.000_464_483_490_365_843_3;
        let c2: f64 = -0.000_289_036_254_605_598_1;
        let c3: f64 = -0.000_874_764_943_953_712_6;
        let c4: f64 = -0.001_029_716_376_139_865_5;
        let c5: f64 = -0.000_836_857_329_713_810_6;
        let c6: f64 = -0.000_488_910_893_527_219;
        let c7: f64 = -0.000_144_236_747_940_817_22;
        let c8: f64 = 0.000_114_363_800_986_163_48;
        let c9: f64 = 0.000_266_806_881_492_777_55;
        let c10: f64 = -0.011_975_517_576_151_07;
        c10.mul_add(a, c9)
            .mul_add(a, c8)
            .mul_add(a, c7)
            .mul_add(a, c6)
            .mul_add(a, c5)
            .mul_add(a, c4)
            .mul_add(a, c3)
            .mul_add(a, c2)
            .mul_add(a, c1)
            .mul_add(a, c0)
    } else {
        let t = 1.0 / (z * (1.0 - 1.0 / (z * z)).sqrt());
        let t2 = t * t;
        let t4 = t2 * t2;
        let t6 = t4 * t2;
        let t8 = t4 * t4;
        let rz = abs_zeta.sqrt();
        let z3 = abs_zeta * abs_zeta * abs_zeta;
        let z32 = rz * rz * rz;
        let z92 = z3 * z32;
        let term1 = t4
            * (4_465_125.0
            + 94_121_676.0 * t2
            + 349_922_430.0 * t4
            + 446_185_740.0 * t6
            + 185_910_725.0 * t8)
            / 39_813_120.0;
        let term2 = -40_415_375.0 / (127_401_984.0 * z3 * z3);
        let term3 = 95095.0 / 15_925_248.0 * t * (3.0 + 5.0 * t2) / z92;
        let term4 = -455.0 / 5_308_416.0 * t2 * (81.0 + 462.0 * t2 + 385.0 * t4) / z3;
        let term5 =
            7.0 / 19_906_560.0 * t * t2 * (30375.0 + 369_603.0 * t2 + 765_765.0 * t4 + 425_425.0 * t6)
                / z32;
        term1 + term2 + term3 + term4 + term5
    }
}

fn olver_a3(z: f64) -> f64 {
    if z < 0.9 {
        let x = 20.0 * z / 9.0 - 1.0;
        let c = cheb_eval_e(x, &(*A3_LT1_DATA), -1.0, 1.0);
        c.val
    } else if z < 1.1 {
        let a: f64 = 1.0 - z;
        let c0: f64 = -0.000_354_211_971_457_743_84;
        let c1: f64 = -0.000_312_322_527_890_318_83;
        let c2: f64 = 0.000_277_947_465_383_133_95;
        let c3: f64 = 0.000_919_803_044_747_967;
        let c4: f64 = 0.001_147_600_388_275_977_7;
        let c5: f64 = 0.000_869_239_326_123_625_8;
        let c6: f64 = 0.000_287_392_257_282_507_34;
        c6.mul_add(a, c5)
            .mul_add(a, c4)
            .mul_add(a, c3)
            .mul_add(a, c2)
            .mul_add(a, c1)
            .mul_add(a, c0)
    } else {
        let x = 11.0 / (5.0 * z) - 1.0;
        let zi2 = 1.0 / (z * z);
        let c = cheb_eval_e(x, &(*A3_GT1_DATA), -1.0, 1.0);
        c.val * zi2 * zi2 * zi2
    }
}

fn olver_a4(z: f64) -> f64 {
    if z < 0.8 {
        let x = 5.0 * z / 2.0 - 1.0;
        let c = cheb_eval_e(x, &(*A4_LT1_DATA), -1.0, 1.0);
        c.val
    } else if z < 1.2 {
        let a: f64 = 1.0 - z;
        let c0: f64 = 0.000_378_194_199_201_772_9;
        let c1: f64 = 0.000_404_943_905_523_632_3;
        let c2: f64 = -0.000_457_647_355_289_361_13;
        let c3: f64 = -0.001_653_610_442_296_502_2;
        let c4: f64 = -0.002_175_275_179_833_600_7;
        let c5: f64 = -0.001_520_032_878_664_907_3;
        c5.mul_add(a, c4)
            .mul_add(a, c3)
            .mul_add(a, c2)
            .mul_add(a, c1)
            .mul_add(a, c0)
    } else {
        let x = 12.0 / (5.0 * z) - 1.0;
        let zi2 = 1.0 / (z * z);
        let c = cheb_eval_e(x, &(*A4_GT1_DATA), -1.0, 1.0);
        c.val * zi2 * zi2 * zi2 * zi2
    }
}

#[inline]
fn olver_asum(nu: f64, z: f64, abs_zeta: f64) -> (f64, f64) {
    let nu2 = nu * nu;
    let (a1, a1_err) = olver_a1(z, abs_zeta);
    let a2 = olver_a2(z, abs_zeta);
    let a3 = olver_a3(z);
    let a4 = olver_a4(z);
    let err = a1_err / nu2 + f64::EPSILON;
    (
        1.0 + a1 / nu2 + a2 / (nu2 * nu2) + a3 / (nu2 * nu2 * nu2) + a4 / (nu2 * nu2 * nu2 * nu2),
        err,
    )
}

#[inline]
fn olver_bsum(nu: f64, z: f64, abs_zeta: f64) -> f64 {
    let nu2 = nu * nu;
    let b0 = olver_b0(z, abs_zeta);
    let b1 = olver_b1(z, abs_zeta);
    let b2 = olver_b2(z);
    let b3 = olver_b3(z);
    b0 + b1 / nu2 + b2 / (nu2 * nu2) + b3 / (nu2 * nu2 * nu2 * nu2)
}

/* uniform asymptotic, nu -> Inf, [Abramowitz+Stegun, 9.3.35]
 *
 * error:
 *    nu =  2: uniformly good to >  6D
 *    nu =  5: uniformly good to >  8D
 *    nu = 10: uniformly good to > 10D
 *    nu = 20: uniformly good to > 13D
 *
*/
pub(super) fn besseljv_asymp_olver_e(nu: f64, x: f64) -> SpecFunResult<f64> {
    let mut result = SpecFunResult::<f64>::default();

    if x <= 0.0 || nu <= 0.0 {
        result.code = SpecFunCode::DomainErr;
        result.val = f64::NAN;
        result.err = f64::NAN;
        result
    } else {
        let z = x / nu;
        let crnu = nu.powf(1.0 / 3.0);
        let nu3 = nu * nu * nu;
        let nu11 = nu3 * nu3 * nu3 * nu * nu;
        let mut pre;
        let zeta;
        let abs_zeta;

        if (1.0 - z).abs() < 0.02 {
            let a: f64 = 1.0 - z;
            let c0: f64 = 1.259_921_049_894_873_2;
            let c1: f64 = 0.377_976_314_968_461_96;
            let c2: f64 = 0.230_385_563_409_348_24;
            let c3: f64 = 0.165_909_603_649_648_68;
            let c4: f64 = 0.129_313_870_864_510_1;
            let c5: f64 = 0.105_680_461_888_581_34;
            let c6: f64 = 0.089_169_979_522_681_87;
            let c7: f64 = 0.077_000_149_006_188_03;

            pre = c7
                .mul_add(a, c6)
                .mul_add(a, c5)
                .mul_add(a, c4)
                .mul_add(a, c3)
                .mul_add(a, c2)
                .mul_add(a, c1)
                .mul_add(a, c0);

            zeta = a * pre;
            pre = (2.0 * (pre / (1.0 + z)).sqrt()).sqrt();
            abs_zeta = zeta.abs();
        } else if z < 1.0 {
            let rt = (1.0 - z * z).sqrt();
            abs_zeta = 1.5 * (((1.0 + rt) / z).ln() - rt).powf(2.0 / 3.0);
            zeta = abs_zeta;
            pre = (2.0 * (abs_zeta / (rt * rt)).sqrt()).sqrt();
        } else {
            /* z > 1 */
            let rt = z * (1.0 - 1.0 / (z * z)).sqrt();
            abs_zeta = 1.5 * (rt - (1.0 / z).acos()).powf(2.0 / 3.0);
            zeta = -abs_zeta;
            pre = (2.0 * (abs_zeta / (rt * rt)).sqrt()).sqrt();
        }

        let (asum, asum_err) = olver_asum(nu, z, abs_zeta);
        let bsum = olver_bsum(nu, z, abs_zeta);

        let arg = crnu * crnu * zeta;
        let ai = arg.airy_ai_e();
        let aip = arg.airy_ai_deriv_e();

        result.val = pre * (ai.val * asum / crnu + aip.val * bsum / (nu * crnu * crnu));
        result.err = pre * (ai.err * (asum / crnu).abs());
        result.err += pre * ai.val.abs() * asum_err / crnu;
        result.err += pre * (ai.val * asum).abs() / (crnu * nu11);
        result.err += 8.0 * f64::EPSILON * result.val.abs();

        result
    }
}

/* uniform asymptotic, nu -> Inf,  [Abramowitz+Stegun, 9.3.36]
 *
 * error:
 *    nu =  2: uniformly good to >  6D
 *    nu =  5: uniformly good to >  8D
 *    nu = 10: uniformly good to > 10D
 *    nu = 20: uniformly good to > 13D
*/
pub(super) fn besselyv_asymp_olver_e(nu: f64, x: f64) -> SpecFunResult<f64> {
    let mut result = SpecFunResult::<f64>::default();

    if x <= 0.0 || nu <= 0.0 {
        result.code = SpecFunCode::DomainErr;
        result.val = f64::NAN;
        result.err = f64::NAN;
        return result;
    } else {
        let z = x / nu;
        let crnu = nu.powf(1.0 / 3.0);
        let nu3 = nu * nu * nu;
        let nu11 = nu3 * nu3 * nu3 * nu * nu;

        let mut pre;
        let zeta;
        let abs_zeta;

        if (1.0 - z).abs() < 0.02 {
            let a: f64 = 1.0 - z;
            let c0: f64 = 1.259_921_049_894_873_2;
            let c1: f64 = 0.377_976_314_968_461_96;
            let c2: f64 = 0.230_385_563_409_348_24;
            let c3: f64 = 0.165_909_603_649_648_68;
            let c4: f64 = 0.129_313_870_864_510_1;
            let c5: f64 = 0.105_680_461_888_581_34;
            let c6: f64 = 0.089_169_979_522_681_87;
            let c7: f64 = 0.077_000_149_006_188_03;

            pre = c7
                .mul_add(a, c6)
                .mul_add(a, c5)
                .mul_add(a, c4)
                .mul_add(a, c3)
                .mul_add(a, c2)
                .mul_add(a, c1)
                .mul_add(a, c0);

            zeta = a * pre;
            pre = (2.0 * (pre / (1.0 + z)).sqrt()).sqrt();
            abs_zeta = zeta.abs();
        } else if z < 1.0 {
            let rt = (1.0 - z * z).sqrt();
            abs_zeta = (1.5 * (((1.0 + rt) / z).ln() - rt)).powf(2.0 / 3.0);
            zeta = abs_zeta;
            pre = (2.0 * (abs_zeta / (rt * rt)).sqrt()).sqrt();
        } else {
            /* z > 1 */
            let rt = z * (1.0 - 1.0 / (z * z)).sqrt();
            let ac = (1.0 / z).acos();
            abs_zeta = (1.5 * (rt - ac)).powf(2.0 / 3.0);
            zeta = -abs_zeta;
            pre = (2.0 * abs_zeta.sqrt() / rt).sqrt();
        }

        let (asum, asum_err) = olver_asum(nu, z, abs_zeta);
        let bsum = olver_bsum(nu, z, abs_zeta);

        let arg = crnu * crnu * zeta;
        let bi = arg.airy_bi_e();
        let bip = arg.airy_bi_deriv_e();

        result.val = -pre * (bi.val * asum / crnu + bip.val * bsum / (nu * crnu * crnu));
        result.err = pre * (bi.err * (asum / crnu).abs());
        result.err += pre * bi.val.abs() * asum_err / crnu;
        result.err += pre * (bi.val * asum).abs() / (crnu * nu11);
        result.err += 8.0 * f64::EPSILON * result.val.abs();
    }
    result
}
